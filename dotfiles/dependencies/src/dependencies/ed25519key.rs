use std::{fs::metadata, sync::RwLock};

use singleton_derive::Singleton;

use super::{DependencyError, DependencyInfo, DependencyInstallable, InstallationStatus};
use crate::{command::DCommand, HOME_DIR};
use lazy_static::lazy_static;

lazy_static! {
    static ref ID_ED25519_KEY: String = format!("{}/.ssh/id_ed25519", *HOME_DIR);
    static ref PUB_ID_ED25519_KEY: String = format!("{}/.ssh/id_ed25519.pub", *HOME_DIR);
}

#[derive(Debug, Default, Singleton)]
pub struct Ed25519Key {
    // current_version: Option<String>,
    ed25519_key_available: RwLock<bool>,
}

impl DependencyInfo for Ed25519Key {
    fn name(&self) -> &'static str {
        "ed25519key"
    }

    fn requires(&self) -> Vec<&'static dyn DependencyInstallable> {
        vec![
            // Ssh::singleton(), //FIXME
            // OpenSshClient::singleton() // required for ssh-keygen
        ]
    }
}

impl DependencyInstallable for Ed25519Key {
    fn is_installed(&self) -> Result<InstallationStatus, DependencyError> {
        // check if ed25519 key is present
        let is_present = metadata(&*ID_ED25519_KEY).is_ok();
        *self.ed25519_key_available.write().unwrap() = is_present;
        match is_present {
            true => Ok(InstallationStatus::FullyInstalled),
            false => Ok(InstallationStatus::NotInstalled),
        }
    }

    fn install(&self) -> Result<(), DependencyError> {
        if *self.ed25519_key_available.read().unwrap() {
            return Ok(());
        }

        // Generate ed25519 key
        //XXX: Set username/hostname combo for this!
        DCommand::new(
            "ssh-keygen",
            &["-t", "ed25519", "-C", "Autogenerated key from dotfiles"],
        )
        .run()?;
        Ok(())
    }
}
